{"version":3,"file":"static/js/381.26245d5d.chunk.js","mappings":"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","sources":["Splash.js"],"sourcesContent":["import React, { memo, useRef, useEffect, useState, Suspense, useCallback } from 'react';\r\nimport { Canvas, useFrame, useLoader, useThree } from '@react-three/fiber';\r\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\r\nimport { PlaneGeometry, LOD, Color, MeshPhysicalMaterial, Box3, Vector3, Mesh, BackSide, PCFSoftShadowMap, sRGBEncoding } from 'three';\r\nimport { Bloom, DepthOfField, EffectComposer, SMAA   } from '@react-three/postprocessing';\r\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader'\r\nimport { useInView } from 'react-intersection-observer'\r\n\r\n// import WebGPUExample from './WebGPUExample';\r\n\r\nfunction GLTFModel() {\r\n  const gltfRef = useRef();\r\n\r\n\r\n  const gltf = useLoader(GLTFLoader, '/crystal_compressed.gltf', (loader) => {\r\n    const dracoLoader = new DRACOLoader();\r\n    dracoLoader.setDecoderPath(\"https://www.gstatic.com/draco/v1/decoders/\");\r\n    dracoLoader.setDecoderConfig({ type: 'js' });\r\n    loader.setDRACOLoader(dracoLoader);\r\n  });\r\n\r\n\r\n  const { camera, size } = useThree();\r\n\r\n\r\n  const setCameraPosition = useCallback(() => {\r\n    const crystalMesh = gltfRef.current?.getObjectByName('crystal');\r\n\r\n    if (crystalMesh) {\r\n      const boundingBox = new Box3();\r\n      const center = new Vector3();\r\n    \r\n      boundingBox.setFromObject(crystalMesh);\r\n      boundingBox.getCenter(center);\r\n      const size = boundingBox.getSize(new Vector3());\r\n\r\n      const maxDim = Math.max(size.x, size.y, size.z);\r\n      const fov = camera.fov * (Math.PI / 180);\r\n      const cameraZ = Math.max(Math.abs((maxDim / 2) / Math.tan(fov / 2)), camera.near + 0.01);\r\n\r\n      camera.near = 0.1;\r\n      camera.far = 100;\r\n      camera.position.set(center.x, center.y, cameraZ);\r\n      // camera.lookAt(center.x, center.y, 0);\r\n    }\r\n  }, [camera]);\r\n\r\n  useEffect(() => {\r\n    const crystalMesh = gltfRef.current?.getObjectByName('crystal');\r\n\r\n    if (crystalMesh) {\r\n      const lod = new LOD();\r\n      const highDetail = crystalMesh.clone();\r\n      const mediumDetail = highDetail.clone();\r\n      const lowDetail = highDetail.clone();\r\n\r\n      highDetail.scale.set(1, 1, 1);\r\n      mediumDetail.scale.set(1.2, 1.2, 1.2);\r\n      lowDetail.scale.set(1.5, 1.5, 1.5);\r\n\r\n      lod.addLevel(highDetail, 0);\r\n      lod.addLevel(mediumDetail, 50);\r\n      lod.addLevel(lowDetail, 100);\r\n\r\n      gltfRef.current.add(lod);\r\n    }\r\n  }, [gltfRef]);\r\n\r\n  // const handleMouseMoveDebounced = debounce((event) => {\r\n  //   const mouseX = (event.clientX / window.innerWidth) * 2 - 1;\r\n  //   const mouseY = - (event.clientY / window.innerHeight) * 2 + 1;\r\n  //   setMousePosition({ x: mouseX, y: mouseY });\r\n  // }, 4);\r\n\r\n  // useEffect(() => {\r\n  //   window.addEventListener('mousemove', handleMouseMoveDebounced);\r\n\r\n  //   return () => {\r\n  //     window.removeEventListener('mousemove', handleMouseMoveDebounced);\r\n  //   };\r\n  // }, [handleMouseMoveDebounced]);\r\n\r\n  useFrame(({ mouse, clock }) => {\r\n    setCameraPosition();\r\n\r\n    const crystalMesh = gltfRef.current?.getObjectByName('crystal');\r\n    const foilMesh = gltfRef.current?.getObjectByName('foil');\r\n\r\n    if (crystalMesh) {\r\n      crystalMesh.rotation.y += 0.02 * mouse.x;\r\n      crystalMesh.rotation.x -= 0.02 * mouse.y;\r\n\r\n      // Animate the plane's tilt left to right\r\n      if (foilMesh) {\r\n        const tiltAmount = -Math.cos(clock.elapsedTime * Math.PI/2 ); // Adjust the speed as needed\r\n        foilMesh.rotateY( tiltAmount / 200 ); // Adjust the tilt angle as needed\r\n      }\r\n\r\n    }\r\n  });\r\n  \r\n  useEffect(() => {\r\n    const handleResize = () => {\r\n      const { innerWidth, innerHeight } = window;\r\n\r\n      camera.aspect = innerWidth / innerHeight;\r\n      camera.updateProjectionMatrix();\r\n      size.width = innerWidth;\r\n      size.height = innerHeight;\r\n\r\n      const innerCanvasElement = document.getElementById('splash-canvas')?.querySelector('canvas');\r\n      if (innerCanvasElement) {\r\n        innerCanvasElement.style.width = `${innerWidth}px`;\r\n        innerCanvasElement.style.height = `${innerHeight}px`;\r\n      }\r\n    };\r\n\r\n    window.addEventListener('resize', handleResize);\r\n\r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n  }, [camera, size]);\r\n\r\n  useEffect(() => {\r\n    if (gltfRef.current) {\r\n      gltfRef.current.traverse((child) => {\r\n        if (child.isMesh && child.name === 'Cylinder') {\r\n          child.name = 'crystal';\r\n\r\n          child.material = new MeshPhysicalMaterial({\r\n\r\n            color: 0xFF11FF, //0xFF11FF\r\n            metalness: 0.9,\r\n            roughness: 0.5,\r\n            transmission: 1,\r\n            transparent: true,\r\n            opacity: 0.92,\r\n            clearcoat: 1,\r\n            clearcoatRoughness: 0,\r\n            sheen: 1,\r\n            sheenRoughness: 0.9,\r\n            sheenColor: new Color(0x330033),\r\n            specularIntensity: 1,\r\n            specularColor: new Color(0xaaaaaa),\r\n            ior: 2.419,\r\n            reflectivity: 0.7,\r\n            iridescence: 10,\r\n            iridescenceIOR: 1.5,\r\n            iridescenceThicknessRange: [10, 4000],\r\n            emissive: 0x440099,\r\n            emissiveIntensity: 4,\r\n            flatShading: false\r\n\r\n          });\r\n          child.castShadow = true;\r\n          child.receiveShadow = true;\r\n          child.depthTest = true;\r\n          child.depthWrite = true;\r\n        }\r\n        \r\n      });\r\n    }\r\n  }, [gltfRef]);\r\n\r\n  useEffect(() => {\r\n    // Vertex shader\r\n  //   const vertexShader = `\r\n  //   varying vec2 vUv;\r\n  //   varying vec3 vViewPosition;\r\n  //   uniform float time;\r\n\r\n  //   // Function to generate a random value between -1 and 1\r\n  //   float random(vec2 co) {\r\n  //     return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453) * 2.0 - 1.0;\r\n  //   }\r\n\r\n  //   void main() {\r\n  //     vUv = uv;\r\n  //     vec3 newPosition = position;\r\n\r\n  //     // Apply a rotation to create a subtle spiral animation\r\n  //     float angle = time * 0.01; // Adjust the multiplier for speed\r\n  //     float x = newPosition.x * cos(angle) - newPosition.y * sin(angle);\r\n  //     float y = newPosition.x * sin(angle) + newPosition.y * cos(angle);\r\n  //     // Random displacement for peaks and valleys\r\n  //     float displacement = random(newPosition.xy) * 10.0 + sin(random(newPosition.xy) + time);\r\n  //     // Apply the displacement to the Y coordinate\r\n  //     newPosition.z += displacement;\r\n  //     newPosition.x = x;\r\n  //     newPosition.y = y;\r\n  //     gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\r\n  //   }\r\n  // `;\r\n\r\n\r\n    // Fragment shader\r\n    // const fragmentShader = `\r\n    // varying vec2 vUv;\r\n    // varying vec3 vViewPosition;\r\n    // uniform float time;\r\n    // uniform vec3 directionalLight1Color;\r\n    // uniform vec3 directionalLight2Color;\r\n    // uniform vec3 directionalLight3Color;\r\n    // uniform vec3 directionalLight1Direction;\r\n    // uniform vec3 directionalLight2Direction;\r\n    // uniform vec3 directionalLight3Direction;\r\n\r\n    // vec3 computeLighting(vec3 lightDirection, vec3 lightColor) {\r\n    //   float diffuse = max(dot(vViewPosition, lightDirection), 0.0);\r\n    //   vec3 reflectDir = reflect(-lightDirection, vViewPosition);\r\n    //   float specular = pow(max(dot(normalize(reflectDir), normalize(vec3(0.0, 0.0, 1.0))), 0.0), 32.0);\r\n    //   return lightColor * (diffuse + specular);\r\n    // }\r\n    // void main() {\r\n    //   // Define a color palette with blues, greens, purples, and reds\r\n    //   vec3 palette = vec3(\r\n    //     0.1 + 0.5 * sin(time),\r\n    //     0.1 + 0.5 * sin(time + 2.0),\r\n    //     0.1 + 0.5 * sin(time + 4.0)\r\n    //   );\r\n      \r\n    //   // Map the color to the desired range, excluding yellows\r\n    //   vec3 color = vec3(\r\n    //     smoothstep(0.0, 1.0, palette.r) + smoothstep(0.7, 1.0, palette.r),  // Red\r\n    //     smoothstep(0.0, 0.0, palette.g),  // Green\r\n    //     smoothstep(0.5, 1.0, palette.b)   // Blue\r\n    //   ) * 1.0;\r\n      \r\n    //   // Ambient occlusion\r\n    //   float ao = smoothstep(0.2, 1.0, 1.0 - length(vUv));\r\n\r\n    //   // Combine the lighting contributions\r\n    //   vec3 finalColor = color +\r\n    //     computeLighting(normalize(directionalLight1Direction), directionalLight1Color) +\r\n    //     computeLighting(normalize(directionalLight2Direction), directionalLight2Color) +\r\n    //     computeLighting(normalize(directionalLight3Direction), directionalLight3Color);\r\n\r\n    //   // Apply ambient occlusion\r\n    //   // finalColor *= ao;\r\n\r\n    //   // Tonemapping to prevent blown-out highlights\r\n    //   finalColor = finalColor / (finalColor + vec3(1.0));\r\n    //   finalColor = pow(finalColor, vec3(1.0 / 0.9));\r\n    //   finalColor = mix(vec3(0.5), finalColor, 4.0); // Adjust the mix factor as needed\r\n\r\n    //   gl_FragColor = vec4(finalColor, 0.001); // Set alpha to 1.0 for full opacity\r\n    // }\r\n    // `;\r\n\r\n\r\n    const planeGeometry = new PlaneGeometry(100, 100, 128, 128);\r\n\r\n\r\n    \r\n    const planeMaterial = new MeshPhysicalMaterial({\r\n      // attenuationColor: 0x0ff,\r\n      color: 0x0000aa, // Set your desired background color here\r\n      metalness: 1.0,\r\n      roughness: 0.7,\r\n      transmission: 1,\r\n      transparent: true,\r\n      opacity: 1.0,\r\n      clearcoat: 0,\r\n      clearcoatRoughness: 0,\r\n      sheen: 1,\r\n      sheenRoughness: 0.0,\r\n      // sheenColor: new Color(0x330033),\r\n      specularIntensity: 0,\r\n      // specularColor: new Color(0xaaaaaa),\r\n      ior: 1.5,\r\n      reflectivity: 0.0,\r\n      iridescence: 1.0,\r\n      iridescenceIOR: 1.4,\r\n      iridescenceThicknessRange: [100, 400],\r\n      emissive: 0x10a,\r\n      emissiveIntensity: 400,\r\n      flatShading: false,\r\n      side: BackSide\r\n    });\r\n  \r\n    \r\n\r\n    const planeMesh = new Mesh(planeGeometry, planeMaterial);\r\n    planeMesh.material = planeMaterial; \r\n    planeMesh.position.set(0, 0, -1);\r\n\r\n    const cameraDirection = new Vector3();\r\n    camera.getWorldDirection(cameraDirection);\r\n    planeMesh.lookAt(\r\n      planeMesh.position.x + cameraDirection.x,\r\n      planeMesh.position.y + cameraDirection.y,\r\n      planeMesh.position.z + cameraDirection.z\r\n    );\r\n\r\n    planeMesh.name = 'foil';\r\n    planeMesh.castShadow = true;\r\n    planeMesh.receiveShadow = true;\r\n    planeMesh.ref = planeMesh;\r\n\r\n    gltfRef.current.add(planeMesh);\r\n\r\n    \r\n  }, [gltfRef, camera]);\r\n\r\n  \r\n\r\n  return <primitive object={gltf.scene} ref={gltfRef} />;\r\n}\r\n\r\n\r\nconst Splash = memo(function Splash() {\r\n  let pixelRatio = window.devicePixelRatio\r\n\r\n  const { ref, inView } = useInView({ trackVisibility: true, delay: 100 });\r\n  // const [key, setKey] = useState(0); // Add key state\r\n\r\n  // console.log('InView:', inView);\r\n  const [shadowMapSize, setShadowMapSize] = useState({\r\n    width: window.innerWidth,\r\n    height: window.innerHeight,\r\n  });\r\n\r\n  useEffect(() => {\r\n    const handleResize = () => {\r\n      // Update the state with the new shadow map size\r\n      // setKey((prevKey) => prevKey + 1); // Increment key to trigger remount\r\n\r\n      setShadowMapSize(calculateShadowMapSize((prevSize) => {\r\n        return prevSize;\r\n      }));\r\n    };\r\n  \r\n    window.addEventListener('resize', handleResize);\r\n  \r\n    // Call handleResize once to set the initial shadow map size\r\n    handleResize();\r\n  \r\n    return () => {\r\n      window.removeEventListener('resize', handleResize);\r\n    };\r\n  }, []);\r\n  \r\n  const calculateShadowMapSize = (callback) => {\r\n    const canvas = document.getElementById('splash-canvas');\r\n    if (canvas) {\r\n      const width = canvas.clientWidth || window.innerWidth;\r\n      const height = canvas.clientHeight || window.innerHeight;\r\n  \r\n      // You can adjust the multiplier as needed\r\n      const multiplier = 4;\r\n  \r\n      const newSize = {\r\n        width: Math.ceil(width * multiplier),\r\n        height: Math.ceil(height * multiplier),\r\n      };\r\n  \r\n      callback(newSize);\r\n  \r\n      return newSize;\r\n    }\r\n  \r\n    return { width: 0, height: 0 };\r\n  };\r\n\r\n\r\n  return (\r\n\r\n    <section id=\"home\">\r\n\r\n      <div className=\"splash-container\" >\r\n        <div className=\"splash-main-container\">\r\n          <div className=\"main-content\" ref={ref} >\r\n            {/* <canvas id=\"canvas-container\"></canvas> */}\r\n            {/* <WebGPUExample /> */}\r\n            <Suspense fallback={null}>\r\n              <Canvas id=\"splash-canvas\"\r\n                frameloop={inView ? 'always' : 'never'}\r\n                style={{ height: '100vh', width: '100%' }}\r\n                antialias=\"false\"\r\n                alpha=\"true\"\r\n                // performance={{ min: 0.5 }}\r\n                colormanagement={\"true\"}\r\n                shadows={{ enabled: true, type: PCFSoftShadowMap, autoUpdate: true }}\r\n                gammafactor={2.2}\r\n                outputencoding = {sRGBEncoding}\r\n\r\n              >\r\n\r\n                 <directionalLight position={[-2, 1, 2]}\r\n                  intensity={10}\r\n                  color={[0.4, 0.4, 1]}\r\n                  angle={Math.PI / 2}\r\n                  penumbra={1}\r\n                  lookAt={[0, 0, 0]}\r\n                  castShadow={\"true\"}\r\n                  shadow-mapSize-height={shadowMapSize.height}\r\n                  shadow-mapSize-width={shadowMapSize.width}\r\n                  shadow-camera-near={.1}\r\n                  shadow-camera-far={100}\r\n\r\n                />\r\n                <directionalLight position={[1, -2, -1]}\r\n                  intensity={10}\r\n                  color={[1, 1, 0.4]}\r\n                  angle={Math.PI / 8}\r\n                  penumbra={1}\r\n                  lookAt={[0, 0, 0]}\r\n                  castShadow={\"true\"}\r\n                  shadow-mapSize-height={shadowMapSize.height}\r\n                  shadow-mapSize-width={shadowMapSize.width}\r\n                  shadow-camera-near={.1}\r\n                  shadow-camera-far={100}\r\n                />\r\n                <directionalLight\r\n                  position={[1, -1, 1]}\r\n                  intensity={5}\r\n                  color={[0.4, 1, 1]}\r\n                  angle={Math.PI / 8}\r\n                  penumbra={1}\r\n                  castShadow={\"true\"}\r\n                  shadow-mapSize-height={shadowMapSize.height}\r\n                  shadow-mapSize-width={shadowMapSize.width}\r\n                  shadow-camera-near={.1}\r\n                  shadow-camera-far={100}\r\n                />\r\n                <directionalLight\r\n                  position={[1, 2, 1]}\r\n                  intensity={10}\r\n                  color={0x66ffff}\r\n                  angle={Math.PI / 8}\r\n                  penumbra={1}\r\n                  castShadow={\"true\"}\r\n                  shadow-mapSize-height={shadowMapSize.height}\r\n                  shadow-mapSize-width={shadowMapSize.width}\r\n                  shadow-camera-near={.1}\r\n                  shadow-camera-far={100}\r\n                />\r\n\r\n\r\n                <GLTFModel/>\r\n\r\n\r\n                <EffectComposer>\r\n                  <DepthOfField focusDistance={1} focalLength={6} bokehScale={20 * pixelRatio} />\r\n                  <Bloom luminanceThreshold={1} luminanceSmoothing={0.1} intensity={0.5} />\r\n                  <SMAA />\r\n                </EffectComposer>\r\n              </Canvas>\r\n            </Suspense>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </section>\r\n  );\r\n})\r\n\r\nexport default Splash;\r\n\r\n\r\n"],"names":["GLTFModel","gltfRef","useRef","gltf","useLoader","GLTFLoader","loader","dracoLoader","DRACOLoader","setDecoderPath","setDecoderConfig","type","setDRACOLoader","camera","size","useThree","setCameraPosition","useCallback","_gltfRef$current","crystalMesh","current","getObjectByName","boundingBox","Box3","center","Vector3","setFromObject","getCenter","getSize","maxDim","Math","max","x","y","z","fov","PI","cameraZ","abs","tan","near","far","position","set","useEffect","_gltfRef$current2","lod","LOD","highDetail","clone","mediumDetail","lowDetail","scale","addLevel","add","useFrame","_ref","_gltfRef$current3","_gltfRef$current4","mouse","clock","foilMesh","rotation","tiltAmount","cos","elapsedTime","rotateY","handleResize","_document$getElementB","innerWidth","innerHeight","window","aspect","updateProjectionMatrix","width","height","innerCanvasElement","document","getElementById","querySelector","style","concat","addEventListener","removeEventListener","traverse","child","isMesh","name","material","MeshPhysicalMaterial","color","metalness","roughness","transmission","transparent","opacity","clearcoat","clearcoatRoughness","sheen","sheenRoughness","sheenColor","Color","specularIntensity","specularColor","ior","reflectivity","iridescence","iridescenceIOR","iridescenceThicknessRange","emissive","emissiveIntensity","flatShading","castShadow","receiveShadow","depthTest","depthWrite","planeGeometry","PlaneGeometry","planeMaterial","side","BackSide","planeMesh","Mesh","cameraDirection","getWorldDirection","lookAt","ref","_jsx","object","scene","memo","pixelRatio","devicePixelRatio","inView","useInView","trackVisibility","delay","shadowMapSize","setShadowMapSize","useState","calculateShadowMapSize","prevSize","callback","canvas","clientWidth","clientHeight","multiplier","newSize","ceil","id","children","className","Suspense","fallback","_jsxs","Canvas","frameloop","antialias","alpha","colormanagement","shadows","enabled","PCFSoftShadowMap","autoUpdate","gammafactor","outputencoding","sRGBEncoding","intensity","angle","penumbra","EffectComposer","DepthOfField","focusDistance","focalLength","bokehScale","Bloom","luminanceThreshold","luminanceSmoothing","SMAA"],"sourceRoot":""}